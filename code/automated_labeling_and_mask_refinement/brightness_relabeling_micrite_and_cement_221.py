# -*- coding: utf-8 -*-
"""brightness_relabeling_micrite_and_cement_221.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ec-JKiPdZuWP0tqKUt8U2aRptj4NGIVA

# Brightness Relabeling Script (Micrite and Cement version)

This script is another version of the brightness relabeling script. Both versions are displayed side by side for every image in `updated_image_mask_visualizations_221.py`.
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import torch
import torch.optim as optim
import numpy as np
from pathlib import Path
from tqdm.auto import tqdm

from torchvision.io import read_image, ImageReadMode
import matplotlib.pyplot as plt
from torchvision.io import read_image

from pathlib import Path
from PIL import Image
import numpy as np
import torch
import matplotlib.pyplot as plt
from torchvision.io import read_image

# Where to save the filled masks
out_mask_dir = Path("/content/drive/My Drive/carbonate_imgs_and_masks/my_dataset/micrite_and_cement_adjusted_masks")
out_mask_dir.mkdir(parents=True, exist_ok=True)

# --- Directories ---
image_dir = Path("/content/drive/My Drive/carbonate_imgs_and_masks/my_dataset/img")
mask_dir  = Path("/content/drive/My Drive/carbonate_imgs_and_masks/my_dataset/masks_machine")

IMG_EXTS = {".jpg", ".jpeg", ".png"}

mask_by_stem = {p.stem: p for p in mask_dir.iterdir() if p.is_file()}

pairs = []
for img_path in sorted([p for p in image_dir.iterdir() if p.suffix.lower() in IMG_EXTS]):
    mpath = mask_by_stem.get(img_path.stem)
    if mpath is None:
        print(f"[WARN] Missing mask for image: {img_path.name}")
        continue
    pairs.append((img_path, mpath))

print(f"Found {len(pairs)} image/mask pairs.")

micrite_siv = 3
cement_siv  = 2

def uniques_2d(x2d):
    x_np = x2d.detach().cpu().numpy()
    u, c = np.unique(x_np, return_counts=True)
    return u, c

for img_path, mask_path in pairs:
    # -------- LOAD --------
    img = read_image(str(img_path))    # C,H,W uint8
    mask = read_image(str(mask_path))  # C,H,W (may be 1 or 3)

    # -------- CANONICAL DISPLAY IMAGE (img_disp) --------
    if img.shape[0] == 1:
        img_disp = img.squeeze(0)            # H,W
    else:
        img_disp = img.permute(1, 2, 0)      # H,W,C

    # -------- CANONICAL 2D LABEL MAP (mask_lab) --------
    # If it's already 1-channel labels, use it.
    # If it's 3-channel but actually encoded labels, take channel 0 to avoid RGB unique chaos.
    if mask.shape[0] == 1:
        mask_lab = mask.squeeze(0)           # H,W
    else:
        mask_lab = mask[0]                   # H,W

    # -------- PRINTS THAT MATCH THE DISPLAY --------
    u0, c0 = uniques_2d(mask_lab)
    print("\n" + "="*90)
    print(f"IMAGE: {img_path.name}")
    print(f"MASK : {mask_path.name}")
    print(f"img raw shape : {tuple(img.shape)} | img_disp shape: {tuple(img_disp.shape)}")
    print(f"mask raw shape: {tuple(mask.shape)} | mask_lab shape: {tuple(mask_lab.shape)}")
    print("Mask uniques:", u0)
    print("Counts      :", c0)

    # -------- SHOW ORIGINALS --------
    plt.figure(figsize=(16, 6))
    plt.subplot(1, 2, 1)
    plt.title(f"Image: {img_path.name}")
    if img_disp.ndim == 2:
        plt.imshow(img_disp, cmap="gray")
    else:
        plt.imshow(img_disp)
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.title(f"Mask (label view): {mask_path.name}")
    plt.imshow(mask_lab, cmap="tab20", interpolation="nearest")
    plt.axis("off")
    plt.tight_layout()
    plt.show()

    # -------- LUMINANCE (H,W) --------
    img_f = img.float()
    if img_f.max() > 1:
        img_f = img_f / 255.0

    if img_f.shape[0] == 3:
        luminance = img_f.mean(dim=0)    # H,W
    else:
        luminance = img_f.squeeze(0)     # H,W

    thr = (luminance.min() + luminance.max()) / 2
    lighter_mask = luminance >= thr
    darker_mask  = luminance <  thr

    # -------- DEFINE "FILLABLE" PIXELS ON 2D LABEL MAP --------
    # Your intent: treat {0,2,3} as needing reassignment based on brightness.
    fill_values = torch.tensor([0, 2, 3], device=mask_lab.device)
    fill_pixels = torch.isin(mask_lab, fill_values)   # H,W bool

    micrite_fill = fill_pixels & darker_mask
    cement_fill  = fill_pixels & lighter_mask

    # -------- FILL ON 2D LABEL MAP --------
    new_mask_lab = mask_lab.clone()

    new_mask_lab = torch.where(
        micrite_fill,
        torch.tensor(micrite_siv, dtype=new_mask_lab.dtype, device=new_mask_lab.device),
        new_mask_lab,
    )
    new_mask_lab = torch.where(
        cement_fill,
        torch.tensor(cement_siv, dtype=new_mask_lab.dtype, device=new_mask_lab.device),
        new_mask_lab,
    )

    u1, c1 = uniques_2d(new_mask_lab)
    print("Filled uniques:", u1)
    print("Filled counts :", c1)

    # -------- SAVE AS 2D LABEL MAP --------
    new_mask_img = Image.fromarray(new_mask_lab.detach().cpu().numpy().astype("uint8"))
    out_path = out_mask_dir / mask_path.name
    new_mask_img.save(out_path)
    print(f"Saved filled mask to: {out_path}")

    # -------- SHOW FILLED (MATCHES PRINTS) --------
    plt.figure(figsize=(16, 6))
    plt.subplot(1, 2, 1)
    plt.title("Image (same as above)")
    if img_disp.ndim == 2:
        plt.imshow(img_disp, cmap="gray")
    else:
        plt.imshow(img_disp)
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.title("Filled Mask (label view)")
    plt.imshow(new_mask_lab, cmap="tab20", interpolation="nearest")
    plt.axis("off")
    plt.tight_layout()
    plt.show()

