# -*- coding: utf-8 -*-
"""brightness_relabeling_micrite_221

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nKTmONmN7KLXFAvIR9FMjSJZZEgF1ux1

# Brightness Relabeling Script (Micrite only version)

This script’s purpose was to post-process our machine-generated segmentation masks to reduce unlabeled regions and produce cleaner training labels. It pairs each carbonate image with its corresponding mask, converts the mask into a consistent 2D label map, and then fills pixels marked as “unlabeled” (primarily label 0, and in one case also label 2) using a brightness-based heuristic derived from the original image: darker pixels are reassigned to micrite (label 3) and lighter pixels to cement (label 2), with fallback rules when only one of those classes is present in the mask. The updated masks are saved to a new directory and visualized alongside the original image and mask for verification.
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import torch
import torch.optim as optim
import numpy as np
from pathlib import Path
from tqdm.auto import tqdm

from torchvision.io import read_image, ImageReadMode
import matplotlib.pyplot as plt
from torchvision.io import read_image

import numpy as np
import torch
import matplotlib.pyplot as plt
from torchvision.io import read_image
from pathlib import Path
from PIL import Image

micrite_siv = 3
cement_siv  = 2
IMG_EXTS = {".jpg", ".jpeg", ".png"}

# --- Directories ---
out_mask_dir = Path("/content/drive/My Drive/carbonate_imgs_and_masks/my_dataset/micrite_adjusted_masks")
out_mask_dir.mkdir(parents=True, exist_ok=True)

image_dir = Path("/content/drive/My Drive/carbonate_imgs_and_masks/my_dataset/img")
mask_dir  = Path("/content/drive/My Drive/carbonate_imgs_and_masks/my_dataset/masks_machine")

mask_by_stem = {p.stem: p for p in mask_dir.iterdir() if p.is_file()}

pairs = []
for img_path in sorted([p for p in image_dir.iterdir() if p.suffix.lower() in IMG_EXTS]):
    mpath = mask_by_stem.get(img_path.stem)
    if mpath is None:
        print(f"[WARN] Missing mask for image: {img_path.name}")
        continue
    pairs.append((img_path, mpath))

print(f"Found {len(pairs)} image/mask pairs.")

def tensor_uniques(x_2d_uint_or_int):
    x_np = x_2d_uint_or_int.detach().cpu().numpy()
    u, c = np.unique(x_np, return_counts=True)
    return u, c

for img_path, mask_path in pairs:
    # ---------- LOAD ----------
    img = read_image(str(img_path))   # C,H,W uint8
    mask = read_image(str(mask_path)) # could be 1,H,W or 3,H,W depending on how saved

    # ---------- CANONICAL DISPLAY IMAGE (img_disp) ----------
    # Show RGB if RGB; show grayscale if 1-channel
    if img.shape[0] == 1:
        img_disp = img.squeeze(0)  # H,W
    else:
        img_disp = img.permute(1, 2, 0)  # H,W,C

    # ---------- CANONICAL LABEL MAP FOR STATS (mask_lab) ----------
    # We want a *2D* label map for uniques/processing.
    # If mask is 1-channel -> use it.
    # If mask is 3-channel but actually encoded labels, often all channels are identical;
    # take the first channel as the label map.
    if mask.shape[0] == 1:
        mask_lab = mask.squeeze(0)  # H,W
    else:
        mask_lab = mask[0]          # H,W (prevents RGB-unique chaos)

    # ---------- PRINTS THAT MATCH WHAT YOU SEE ----------
    u0, c0 = tensor_uniques(mask_lab)
    print("\n" + "="*90)
    print(f"IMAGE: {img_path.name}")
    print(f"MASK : {mask_path.name}")
    print(f"img shape (raw) : {tuple(img.shape)} | img_disp shape: {tuple(img_disp.shape)}")
    print(f"mask shape(raw) : {tuple(mask.shape)} | mask_lab shape: {tuple(mask_lab.shape)}")
    print("Mask uniques:", u0)
    print("Counts      :", c0)

    # ---------- SHOW ORIGINALS (MATCHES PRINTS ABOVE) ----------
    plt.figure(figsize=(16, 6))
    plt.subplot(1, 2, 1)
    plt.title(f"Image: {img_path.name}")
    if img_disp.ndim == 2:
        plt.imshow(img_disp, cmap="gray")
    else:
        plt.imshow(img_disp)
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.title(f"Mask (label view): {mask_path.name}")
    plt.imshow(mask_lab, cmap="tab20", interpolation="nearest")
    plt.axis("off")
    plt.tight_layout()
    plt.show()

    # ---------- BRIGHTNESS SPLIT (use a luminance derived from img) ----------
    img_f = img.float()
    if img_f.max() > 1:
        img_f = img_f / 255.0

    if img_f.shape[0] == 3:
        luminance = img_f.mean(dim=0)   # H,W
    else:
        luminance = img_f.squeeze(0)    # H,W

    thr = (luminance.min() + luminance.max()) / 2
    lighter_mask = luminance >= thr
    darker_mask  = luminance <  thr

    # ---------- FILLING ----------
    unique_values = mask_lab.unique()
    micrite_present = (unique_values == micrite_siv).any()
    cement_present  = (unique_values == cement_siv).any()

    new_mask_lab = mask_lab.clone()

    if micrite_present and not cement_present:
        new_mask_lab = torch.where(
            new_mask_lab == 0,
            torch.tensor(micrite_siv, dtype=new_mask_lab.dtype, device=new_mask_lab.device),
            new_mask_lab,
        )

    elif cement_present and not micrite_present:
        new_mask_lab = torch.where(
            new_mask_lab == 0,
            torch.tensor(cement_siv, dtype=new_mask_lab.dtype, device=new_mask_lab.device),
            new_mask_lab,
        )

    elif micrite_present and cement_present:
        # treat 0 and 2 as "unlabeled/needs fill" per your comment
        zero_pixels = torch.isin(new_mask_lab, torch.tensor([0, 2], device=new_mask_lab.device))

        micrite_fill = zero_pixels & darker_mask
        cement_fill  = zero_pixels & lighter_mask

        new_mask_lab = torch.where(
            micrite_fill,
            torch.tensor(micrite_siv, dtype=new_mask_lab.dtype, device=new_mask_lab.device),
            new_mask_lab,
        )
        new_mask_lab = torch.where(
            cement_fill,
            torch.tensor(cement_siv, dtype=new_mask_lab.dtype, device=new_mask_lab.device),
            new_mask_lab,
        )

    u1, c1 = tensor_uniques(new_mask_lab)
    print("Filled mask uniques:", u1)
    print("Filled counts      :", c1)

    # ---------- SAVE (AS 2D LABEL MAP) ----------
    new_mask_img = Image.fromarray(new_mask_lab.detach().cpu().numpy().astype("uint8"))
    out_path = out_mask_dir / mask_path.name
    new_mask_img.save(out_path)
    print(f"Saved filled mask to: {out_path}")

    # ---------- SHOW FILLED (MATCHES PRINTS ABOVE) ----------
    plt.figure(figsize=(16, 6))
    plt.subplot(1, 2, 1)
    plt.title("Image (same as above)")
    if img_disp.ndim == 2:
        plt.imshow(img_disp, cmap="gray")
    else:
        plt.imshow(img_disp)
    plt.axis("off")

    plt.subplot(1, 2, 2)
    plt.title("Filled Mask (label view)")
    plt.imshow(new_mask_lab, cmap="tab20", interpolation="nearest")
    plt.axis("off")
    plt.tight_layout()
    plt.show()