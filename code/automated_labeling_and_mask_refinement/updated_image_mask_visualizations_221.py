# -*- coding: utf-8 -*-
"""updated_image_mask_visualizations_221.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ubV5tjAjRIRPOp--StXcvJBDRWzVrMk9

# Image, Mask, and Relabeled Mask Side-By-Side Visualizations

This notebook shows image and mask visualizations for 50 labeled samples. Each row contains four images: (1) the original image from the labeled dataset, (2) a visualization of the original mask, and (3â€“4) two updated masks generated by my brightness-based relabeling algorithm, designed to better capture background micrite and cement.
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import torch
import torch.optim as optim
import numpy as np
from pathlib import Path
from tqdm.auto import tqdm

from torchvision.io import read_image, ImageReadMode
import matplotlib.pyplot as plt
from torchvision.io import read_image

from pathlib import Path
import matplotlib.pyplot as plt
from torchvision.io import read_image

# --- Directories ---
image_dir = Path("/content/drive/My Drive/carbonate_imgs_and_masks/petrographic_labelled_dataset/my_dataset/img")
mask_dir  = Path("/content/drive/My Drive/carbonate_imgs_and_masks/petrographic_labelled_dataset/my_dataset/masks_machine")

adjusted_version1_dir = Path("/content/drive/My Drive/carbonate_imgs_and_masks/petrographic_labelled_dataset/my_dataset/micrite_adjusted_masks")
adjusted_version2_dir = Path("/content/drive/My Drive/carbonate_imgs_and_masks/petrographic_labelled_dataset/my_dataset/micrite_and_cement_adjusted_masks")

IMG_EXTS = {".jpg", ".jpeg", ".png"}
MASK_EXTS = {".png", ".jpg", ".jpeg"}  # adjust if needed

def index_by_stem(folder: Path, exts: set[str]):
    """Map filename stem -> file path, for files in folder with suffix in exts."""
    if not folder.exists():
        print(f"[WARN] Folder not found: {folder}")
        return {}
    out = {}
    for p in folder.iterdir():
        if p.is_file() and p.suffix.lower() in exts:
            out[p.stem] = p
    return out

# Index masks by stem
mask_machine_by_stem = index_by_stem(mask_dir, MASK_EXTS)
mask_v1_by_stem      = index_by_stem(adjusted_version1_dir, MASK_EXTS)
mask_v2_by_stem      = index_by_stem(adjusted_version2_dir, MASK_EXTS)

# Build pairs from images (stem is the join key)
pairs = []
for img_path in sorted([p for p in image_dir.iterdir() if p.is_file() and p.suffix.lower() in IMG_EXTS]):
    stem = img_path.stem
    m_machine = mask_machine_by_stem.get(stem)
    m_v1      = mask_v1_by_stem.get(stem)
    m_v2      = mask_v2_by_stem.get(stem)

    missing = []
    if m_machine is None: missing.append("machine")
    if m_v1 is None:      missing.append("v1")
    if m_v2 is None:      missing.append("v2")

    if missing:
        print(f"[WARN] Missing {missing} mask(s) for: {img_path.name}")
        # continue
    pairs.append((img_path, m_machine, m_v1, m_v2))

print(f"Found {len(pairs)} image rows.")

def show_mask(ax, mask_tensor, title: str):
    ax.set_title(title)
    ax.axis("off")
    if mask_tensor is None:
        ax.text(0.5, 0.5, "MISSING", ha="center", va="center", fontsize=14)
        return

    # mask_tensor is C,H,W
    if mask_tensor.ndim == 3 and mask_tensor.shape[0] == 1:
        ax.imshow(mask_tensor.squeeze(0), cmap="tab20", interpolation="nearest")
    elif mask_tensor.ndim == 3 and mask_tensor.shape[0] == 3:
        ax.imshow(mask_tensor.permute(1, 2, 0))
    else:
        # fallback: squeeze if possible
        ax.imshow(mask_tensor.squeeze(), cmap="tab20", interpolation="nearest")

def show_img(ax, img_tensor, title: str):
    ax.set_title(title)
    ax.axis("off")
    # img_tensor is C,H,W
    if img_tensor.shape[0] == 1:
        ax.imshow(img_tensor.squeeze(0), cmap="gray")
    else:
        ax.imshow(img_tensor.permute(1, 2, 0))

# Display: Image + 3 masks side-by-side for each stem

for img_path, m_machine_path, m_v1_path, m_v2_path in pairs:
    img = read_image(str(img_path))  # C,H,W uint8
    m_machine = read_image(str(m_machine_path)) if m_machine_path is not None else None
    m_v1      = read_image(str(m_v1_path))      if m_v1_path is not None else None
    m_v2      = read_image(str(m_v2_path))      if m_v2_path is not None else None

    fig, axes = plt.subplots(1, 4, figsize=(22, 6))

    show_img(axes[0], img, f"Image\n{img_path.name}")
    show_mask(axes[1], m_machine, f"Mask (machine)\n{m_machine_path.name if m_machine_path else ''}")
    show_mask(axes[2], m_v1,      f"Mask (Adj v1)\n{m_v1_path.name if m_v1_path else ''}")
    show_mask(axes[3], m_v2,      f"Mask (Adj v2)\n{m_v2_path.name if m_v2_path else ''}")

    plt.tight_layout()
    plt.show()
    print()
    print()

